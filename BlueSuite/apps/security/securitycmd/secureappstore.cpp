/*******************************************************************************
*
*   Copyright (c) 2016-2019 Qualcomm Technologies International, Ltd.
*   All Rights Reserved.
*   Qualcomm Technologies International, Ltd. Confidential and Proprietary.
*
*   This module signs and encrypts a firmware XUV file specific to uenergy app store.
*
*******************************************************************************/
#include "secureappstore.h"
#include "uestores.h"
#include <string.h>

    #define FLAGS_STORETYPE_MASK        0x000F
    #define FLAGS_STORETYPE_APPSTORE    0x0002
    #define FLAGS_ACCESSPERM_MASK       0x00C0
    #define FLAGS_ACCESSPERM_COPY_EXEC  0x0040
    #define FLAGS_SIGNED                (1u << 11u)
    #define FLAGS_ENCRYPTED             (1u << 12u)

/******************************************************************************
@brief Hash the XUV image.

@param[in,out]  aXuvImage   XUV image. Output will contain the hash.
@param[out]     apHash      Generated hash. Provided for signature generation.
@param[in]      aAddrFirst  Address of first word to be hashed.
@param[in]      aAddrLast   Address of last word to be hashed.
@param[in]      aAddrHash   Address of first word to put hash.
@param[in]      aZeroHeader Flag to have the header cleared before calculation.

@note The image is expected to follow the uenergy app store binary format.
*/
void
XuvImageHash(xuv::image &aXuvImage, securlib::HashType *apHash, unsigned int aAddrFirst,
    unsigned int aAddrLast, unsigned int aAddrHash, bool aZeroHeader)
{
    /* copy app store into vector from XUV image (contiguous bytes, BIG endian) */
    xuv::ByteBlockType block = ByteBlockFlattenU16BE(aXuvImage, aAddrFirst, aAddrLast, 0xFF);
    if (aZeroHeader)
    {
        /* Zero the id and storelen fields */
        for (int i = 2; i <= 5; ++i)
        {
            block[i] = 0;
        }
    }
    (void) securlib::HashSha256(apHash, &block[0], block.size());
    /* Push the hash into the XUV image. */
    xuv::ByteBlockIncorporateU16BE(aXuvImage, aAddrHash, apHash->digest, &apHash->digest[SHA256_DIGEST_LENGTH-1]);

}

/******************************************************************************
@brief Sign the hash and put it in the XUV image.

@param[in,out]  aXuvImage       XUV image. Output will contain the signature.
@param[in]      apHash          The hash generated by the XuvImageHash function.
@param[in]      apSignPrvKey    Private key to sign with.
@param[in]      aAddrSignature  Address of first word to put signature.

@note The image is expected to follow the uenergy app store binary format.
*/
void
XuvImageHashSign(xuv::image &aXuvImage, const securlib::HashType *apHash, const RSA_Key *apSignPrvKey, unsigned int aAddrSignature)
{
    securlib::SignatureType signature;
    securlib::SignHash(apSignPrvKey, apHash, &signature);
    /* Push the signature into the XUV image. */
    xuv::ByteBlockIncorporateU16BE(aXuvImage, aAddrSignature, &signature.signature[0], &signature.signature[securlib::SIGNATURE_LENGTH-1]);

}

/******************************************************************************
@brief Encrypt XUV image.

@param[in,out]  aXuvImage   XUV image. Output will contain encrypted data.
@param[in]      aEncKey     Aes128 key for encryption.
@param[in]      aAddrFirst  Address of first word to encrypt.
@param[in]      aAddrLast   Address of last word to encrypt.

@return true on failure (error from OpenSSL encryption functions).

@note The image is expected to follow the uenergy app store binary format.
*/
bool
XuvImageEncrypt(xuv::image &aXuvImage, securlib::Aes128KeyType aEncKey, unsigned int aAddrFirst, unsigned int aAddrLast)
{
    /* Extract application image into vector (contiguous bytes, LITTLE endian) */
    xuv::ByteBlockType block = ByteBlockFlattenU16LE(aXuvImage, aAddrFirst, aAddrLast, 0xFF);
    /* Create output buffer to receive encrypted image. */
    xuv::ByteBlockType DataOut(block.size());
    /* Encrypt the application image. */
    if (! securlib::Encrypt(&DataOut[0], &block[0], (int)(block.size()), aEncKey))
    {
        return true;
    }
    /* Push encrypted image back into XUV image. */
    if(!DataOut.empty())
    {
        xuv::ByteBlockIncorporateU16BE(aXuvImage, aAddrFirst, &DataOut.front(), &DataOut.back());
    }
    return false;
}

/******************************************************************************
@brief Secure the image with hash, signature and encryption as specified.
    This function works on data in memory.

@param[in,out]  aXuvImage   Image with app store.

@param[in,out] aXuvImage    XUV image. Output will contain secured image.
@param[in] apSignPrvKey     Optional Key containing RSA private key for signing.
                            May be NULL in which case image will not be signed.
@param[in] apEncKey         Optional AES128 Encryption key. May be NULL in
                            which case image will not be encrypted.
@param[in] apAddress        Optional start address. NULL will default to using first
                            word in image as start.
@param[in] aCopyExec        Set the Copy-on-execute flag in image.

@return Indicates success or error code:
@retval SECUREAPPSTOREIMG_SUCCESS             Success.
@retval SECUREAPPSTOREIMG_ERR_ENCRYPT         Encryption failed (Error from OpenSSL).
@retval SECUREAPPSTOREIMG_ERR_NO_APP          No app store in image. Invalid image.
@retval SECUREAPPSTOREIMG_ERR_TOO_SMALL       Image is too small to be correct.
@retval SECUREAPPSTOREIMG_ERR_RESERVED_BITS   Reserved bits are set in image. Invaid image.
*/
int SecureAppStoreImage(xuv::image &aXuvImage,
    RSA_Key *apSignPrvKey,
    securlib::Aes128KeyType *apEncKey,
    unsigned int *apAddress,
    bool aCopyExec, bool aZeroHeader)
{
    /******************************************************************************
    Calculate locations within image.
    */
    unsigned int AddrStart = aXuvImage.data.begin()->first;
    /* If app store is not at start of image then use given address */
    if(apAddress)
    {
        AddrStart = *apAddress;
    }
    /* UsedSize is number of octets */
    unsigned int AddrUsedSize = AddrStart + ADDITIONAL_HDR + ADDITIONAL_HDR_USEDSIZE;
    if( !aXuvImage.data.count(AddrUsedSize))
    {
        return SECUREAPPSTOREIMG_ERR_TOO_SMALL;
    }
    size_t UsedSize = NormaliseUsedSize(aXuvImage.data[AddrUsedSize]);
    if(static_cast<size_t>(-1) == UsedSize)
    {
        return SECUREAPPSTOREIMG_ERR_RESERVED_BITS;
    }
    size_t UsedSizeU16 = (UsedSize+1) / 2; /* Used size as number of uint16 words */
    /* AddrLast is inclusive of last address (hence -1) */
    unsigned int AddrLast       = static_cast<unsigned int>(AddrStart - 1 + UsedSizeU16);
    unsigned int AddrFooter     = AddrLast + 1 - FOOTER_SIZE;
    unsigned int AddrSignature  = AddrFooter;
    unsigned int AddrHash       = AddrFooter + SIGNATURE_SIZE;
    unsigned int AddrAppFirst   = AddrStart + APPLICATION_IMG;
    unsigned int AddrAppEnd     = AddrHash + HASH_SIZE;
    unsigned int AddrAppLast    = AddrAppEnd - 1;

    /******************************************************************************
    Check the FLAGS and error if not an app store.
    */
    if((aXuvImage.data[AddrStart] & FLAGS_STORETYPE_MASK) != FLAGS_STORETYPE_APPSTORE)
    {
        return SECUREAPPSTOREIMG_ERR_NO_APP;
    }

    /******************************************************************************
    Check the used size in words is big enough to contain the an app.
    We actually check app is at least 1 byte excluding header and footer.
    Same as UsedSizeU16 <= APPLICATION_IMG+FOOTER_SIZE
    */
    if(AddrFooter <= AddrAppFirst)
    {
        return SECUREAPPSTOREIMG_ERR_TOO_SMALL;
    }

    /******************************************************************************
    Need to calculate and update the FLAGS in the store header.
    */
    unsigned int FlagsRetainMask = ~(FLAGS_SIGNED|FLAGS_ENCRYPTED); /* clear signed and encrypted bits */
    unsigned int FlagsUpdate = 0x0000; /* default to no change */

    /* Update the FLAGS if we're encrypting. */
    if(apEncKey)
    {
        FlagsUpdate |= FLAGS_ENCRYPTED; /* Encrypted flag */
    }

    /* Update the FLAGS if we are signing. */
    if(apSignPrvKey)
    {
        FlagsUpdate |= FLAGS_SIGNED; /* Signed flag */
    }

    /* Must be copy-then-execute for encrypted and optional for signed */
    if(aCopyExec || apEncKey)
    {
        FlagsRetainMask &= ~FLAGS_ACCESSPERM_MASK;
        FlagsUpdate     |= FLAGS_ACCESSPERM_COPY_EXEC;
    }

    /******************************************************************************
    Put updated FLAGS into XUV image before we sign and/or encrypt.
    */
    if(FlagsUpdate)
    {
        aXuvImage.data[AddrStart] = (aXuvImage.data[AddrStart] & FlagsRetainMask) | FlagsUpdate;
    }

    /******************************************************************************
    Create sha256 hash of the App Store
    */
    securlib::HashType hash;
    XuvImageHash(aXuvImage, &hash, AddrStart, AddrFooter-1, AddrHash, aZeroHeader);

    /******************************************************************************
    Sign the hash.
    */
    if (apSignPrvKey)
    {
        XuvImageHashSign(aXuvImage, &hash, apSignPrvKey, AddrSignature);
    }

    /******************************************************************************
    Encrypt image.
    */
    if (apEncKey)
    {
        if (XuvImageEncrypt(aXuvImage, *apEncKey, AddrAppFirst, AddrAppLast))
        {
            return SECUREAPPSTOREIMG_ERR_ENCRYPT;
        }
    }
    return SECUREAPPSTOREIMG_SUCCESS;
}

/******************************************************************************
@brief Secure the image with hash, signature and encryption as specified.
    This function works on data in files (call function SecureAppStoreImage).

@param[in] apInFile         Input XUV image file name.
@param[in] apSignKeyFile    Optional Key file containing RSA private key for signing.
                            May be NULL in which case image will not be signed.
@param[in] apEncrKeyFile    Optional AES128 Encryption key file. May be NULL in
                            which case image will not be encrypted.
@param[in] apOutFile        Output XUV image file name.
@param[in] apAddress        Optional start address. NULL will default to using first
                            word in image as start.
@param[in] aCopyExec        Set the Copy-on-execute flag in image.

@return Indicates success or error code:
@retval FSECUREAPPSTOREIMG_SUCCESS              Success.
@retval FSECUREAPPSTOREIMG_ERR_READ_ENCKEY      Failed to read encryption key from file.
@retval FSECUREAPPSTOREIMG_ERR_READ_SIGKEY      Failed to read signature key from file.
@retval FSECUREAPPSTOREIMG_ERR_READ_IMG         Failed to read XUV image from file.
@retval FSECUREAPPSTOREIMG_ERR_IMG_EMPTY        Image contains no data.
@retval FSECUREAPPSTOREIMG_ERR_WRITE_IMG        Failed to write XUV image to file.
@retval SECUREAPPSTOREIMG_ERR_ENCRYPT           Encryption failed (Error from OpenSSL).
@retval SECUREAPPSTOREIMG_ERR_NO_APP            No app store in image. Invalid image.
@retval SECUREAPPSTOREIMG_ERR_TOO_SMALL         Image is too small to be correct.
@retval SECUREAPPSTOREIMG_ERR_RESERVED_BITS     Reserved bits are set in image. Invaid image.
*/
int FSecureAppStoreImage(const char *apInFile, const char *apSignKeyFile,
    const char *apEncrKeyFile, const char *apOutFile,
    unsigned int *apAddress, bool aCopyExec, bool aZeroHeader)
{
    /******************************************************************************
    Read the encryption key file.
    */
    securlib::Aes128KeyType EncKey = {{0}};
    securlib::Aes128KeyType *pEncKey = NULL;
    if(apEncrKeyFile && strlen(apEncrKeyFile))
    {
        if(securlib::ReadAes128KeyFile(EncKey, apEncrKeyFile))
        {
            return FSECUREAPPSTOREIMG_ERR_READ_ENCKEY;
        }
        pEncKey = &EncKey;

    }
    /******************************************************************************
    Read the signing key file.
    */
    RSA_Key SignPrvKey;
    RSA_Key *pSignPrvKey = NULL;
    if (apSignKeyFile && strlen(apSignKeyFile))
    {
        std::string description = "";
        if(securlib::ReadRsaPrivateKey(&SignPrvKey, apSignKeyFile, description))
        {
            return FSECUREAPPSTOREIMG_ERR_READ_SIGKEY;
        }
        pSignPrvKey = &SignPrvKey;
    }

    /******************************************************************************
    Read XUV file. Get the min and max addresses.
    */
    xuv::image image;
    if(xuv::READ_OK != xuv::Read(image, apInFile))
    {
        return FSECUREAPPSTOREIMG_ERR_READ_IMG;
    }
    if(image.data.empty())
    {
        return FSECUREAPPSTOREIMG_ERR_IMG_EMPTY;
    }

    int result = SecureAppStoreImage(image, pSignPrvKey, pEncKey, apAddress, aCopyExec, aZeroHeader);
    if (result)
    {
        return result;
    }

    /******************************************************************************
    Write the output XUV image.
    */
    if(xuv::WRITE_OK != xuv::Write(image, apOutFile))
    {
        return FSECUREAPPSTOREIMG_ERR_WRITE_IMG;
    }
    return FSECUREAPPSTOREIMG_SUCCESS;
}
